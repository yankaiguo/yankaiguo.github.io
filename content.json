{"meta":{"title":"gykai的博客","subtitle":"","description":"","author":"Yankai Guo","url":"https://yankaiguo.github.io","root":"/"},"pages":[],"posts":[{"title":"C++11","slug":"C++11","date":"2020-10-09T13:14:44.296Z","updated":"2020-10-09T14:13:09.912Z","comments":true,"path":"2020/10/09/C++11/","link":"","permalink":"https://yankaiguo.github.io/2020/10/09/C++11/","excerpt":"","text":"C++11是什么，C++11标准的由来C++11 auto类型推导功能说明C++11 使用auto来做自动类型推导，使用了auto关键字之后，编译器会在编译期间自动推导出变量的类型。 语法说明1auto name = value auto 仅仅是个占位符，在编译器期间它会被真正的类型所替代。 auto的高级用法 auto除了可以独立使用，还可以和某些具体类型混合使用，这样auto表示的就是”半个”类型，而不是完整的类型。例如 12345int x = 0;auto *p1 = &amp;x; //p1为int * , auto 推导为intauto p2 = &amp;x; //p2为int* ，auto推导为int*auto &amp;r1 = x; //r1为int&amp; , auto 推导为intauto r2 = r1; //r1 为int， auto推导为int auto与const的结合 12345int x = 0;const auto n = x; //n为const int， auto被推导为intauto f = n; //f为const int， auto 被推导为int (const 属性为抛弃)const auto &amp;r1 = x; //r1为const int&amp; 类型，auto被推导为intauto &amp;r2 = r1; //r1 时const int&amp; 类型，auto被推导为const int类型。 总结 当类型不为引用时，auto的推导结果将不保留表达式的const属性 当类型为引用时，auto的推导结果将保留表达式的const属性。 auto的限制 auto不能再函数的参数中使用。 auto关键字不能作用于类的非静态成员变量(也就是没有static关键字修饰的成员变量)中。 auto关键字不能定义数组，例如 12char url[] = \"http://c.biancheng.net/\";auto str[] = url; //url为数组，所以不能使用auto auto不能作用于模板参数 auto的应用 auto定义stl的迭代器 auto用于泛型编程 C++11 decltype类型推导功能说明1decltype是C++11新增的一个关键字，它和auto的功能一样，都用来在编译时进行自动类型推导。 语法说明123auto varname &#x3D; value;decltype(exp) varname &#x3D; value; &#x2F;&#x2F;varname表示变量名，value表示赋给变量的值，exp表示一个表达式。decltype根据exp表达式推导出变量的类型，跟&quot;&#x3D;&quot;右边的value没有关系。 auto 要求变量必须初始化，而decltype不要求。 1234int a &#x3D; 0;decltype(a) b &#x3D; 1; &#x2F;&#x2F;b 被推导成了intdecltype(10.8) x &#x3D; 5.5; &#x2F;&#x2F;x 被推到成了doubledecltype(x + 10) y ; &#x2F;&#x2F;y 被推导成了double decltype推导规则 如果exp是一个不被括号()包围的表达式，或者是一个类成员访问表达式，或者是一个单独的表达式，或者是一个单独的变量，那么decltype(exp)的类型就和exp一致。 如果exp是函数调用，那么decltype(exp) 的类型就和函数返回值的类型一致。 如果exp是一个左值，或者被括号()包围，那么decltype(exp)的类型就是exp的引用；假设exp的类型为T,那么decltype(exp)的类型就是T&amp;. 实例112345678910111213141516171819202122232425#include &lt;string&gt;using namespace std;class Student&#123;public: static int total; string name; int age; float scores;&#125;int Student::total = 0;int main()&#123; int n = 0; const int &amp;r = n; Student stu; decltype(n) a = n; //n 为int类型，a被推导为int类型 decltype(r) b = n; //r为const int&amp; 类型，b被推导为const int&amp; 类型 decltype(Student::total) c= 0; //total 为类Student的一个int类型的成员变量，c被推导为int类型 decltype(stu.name) url = \"http://c.biancheng.net/cplus/\"; //name为类Student的一个string类型变量，url被推导为string类型 return 0；&#125; 实例2： exp为函数调用12345678910111213141516&#x2F;&#x2F;函数声明int&amp; func_int_r(int, char); &#x2F;&#x2F;返回类型为int &amp;int&amp;&amp; func_int_rr(void); &#x2F;&#x2F;返回类型为int &amp;&amp;int func_int(double); &#x2F;&#x2F;返回类型为intconst int&amp; fun_cint_r(int,int,int); &#x2F;&#x2F;返回值为const int&amp;const int&amp;&amp; fun_cint_rr(void); &#x2F;&#x2F;返回类型为const int&amp;&amp;&#x2F;&#x2F;decltype 类型推导int n &#x3D; 100;decltype(func_int_r(100,A)) a &#x3D; n; &#x2F;&#x2F;a 的类型为 int&amp;decltype(func_int_rr()) b &#x3D; 0; &#x2F;&#x2F;b的类型为 int&amp;&amp;decltype(func_int(10.5)) c &#x3D; 0; &#x2F;&#x2F;c的类型为 intdecltype(fun_cint_r(1,2,3)) x &#x3D; n; &#x2F;&#x2F;x的类型为 const int&amp;decltype(fun_cint_rr()) y &#x3D; 0; &#x2F;&#x2F;y的类型为 const int&amp;&amp; 实例3 ：exp是左值，或者被()包围123456789101112131415161718192021using namespace std;class Base&#123;public: int x;&#125;;int main()&#123; const Base obj; &#x2F;&#x2F;带有括号的表达式 decltype(obj.x) a &#x3D; 0; &#x2F;&#x2F;obj.x为类的成员访问表达式，符合推导规则1，a的类型为int decltype((obj.x)) b &#x3D; a; &#x2F;&#x2F;obj.x 带有括号，符合推导规则三，b的类型类型为 int&amp; &#x2F;&#x2F;加法表达式 int n&#x3D;0, m &#x3D; 0; decltype(m+n) c &#x3D; 0; &#x2F;&#x2F;m+n得到一个右值，符合推到规则一，所以推导结果为int decltype(n&#x3D;n+m) d &#x3D; c; &#x2F;&#x2F;n&#x3D;n+m得到一个左值，符号推导规则三，所以推导结果为int&amp; return 0;&#125; decltype 的实际应用 推导非静态成员的类型 C++11 auto和decltype的区别语法格式的区别12auto varname &#x3D; value; &#x2F;&#x2F;auto的语法格式decltype(exp) varname[&#x3D;value]; &#x2F;&#x2F;decltype的语法格式 对cv限定符的处理 [cv限定符]是const 和volatile关键字的统称 12const 关键字用来表示数据是只读的，页就是不能被修改voltile 和const 是相反的，它用来表示数据是可变的，易变的，目的是不让CPU将数据缓存到寄存器，而是从原始的内存中读取。 decltype会保留cv限定符，而auto有可能会去掉cv限定符。（当推导类型不是指针或引用时，会去掉cv限定符） 对引用的处理1当表达式的类型为引用时，auto和decltype的推导规则页不一样，decltype会保留引用类型，而auto会抛弃引用类型，直接推导出它的原始类型。 C++11 返回值类型后置功能说明12在泛型编程中，可能需要通过参数的运算来得到返回值的类型。在C++中增加了返回类型后置(trailing-return-type,又称跟踪返回类型)语法，将decltype和auto结合起来完成返回值类型的推导。 例子一12345template &lt;typename T, Typename U&gt;auto add(T t, U u) -&gt; decltype(t+u)&#123; return t+u;&#125; 例子二12345678int&amp; foo(int &amp;i);float foo(float &amp;f)template &lt;typename T&gt;auto func(T&amp; var) -&gt; decltype(foo(var))&#123; return foo(var);&#125; 应用1返回值类型后置语法，是为了解决返回返回值类型依赖于参数而导致难以确定返回值类型的问题，有了这种语法以后，对返回值类型的推导就可以用清晰的方式(直接通过参数做运算)描述出来，而不需要像C++98&#x2F;03那样使用晦涩难懂的写法。 C++11 对模板实例化中连续右尖括号&gt;&gt;的改进1在C++98&#x2F;03的泛型编程中，模板实例化有一个很繁琐的地方，那就是连续两个右尖括号(&gt;&gt;)会被编译器解释成右移操作符，而不是模板参数表的结束。 C++11 使用using定义别名(替代typedef) typedef 的用法 1typedef unsigned int uint_t typedef的限制 1无法重定义一个模板 C++11中出现了可以重定义一个模板的语法 1234template &lt;typename Val&gt;using str_map_t &#x3D; std::map&lt;std::string, Val&gt;&#x2F;&#x2F; ...str_map_t&lt;int&gt; map1 typedef 与using语法对比 123456789&#x2F;&#x2F;重定义unsigned inttypedef unsigned int uint_t;using uint_t &#x3D; unsigned int;&#x2F;&#x2F;重定义std::maptypedef std::map&lt;std::string, str&gt; map_int_t;using map_int_t &#x3D; std::map&lt;std::string, int&gt;;&#x2F;&#x2F;重定义一个函数指针typedef void(*func_t)(int, int);using func_t &#x3D; void(*)(int, int); using 定义模板别名 1234567891011121314&#x2F;* C++98&#x2F;03 *&#x2F;template &lt;typename T&gt;struct func_t&#123; typedef void(*type)(T, T);&#125;;&#x2F;&#x2F;使用func_t 模板func_t&lt;int&gt;::type xx_t;&#x2F;* C++11 *&#x2F;template &lt;typename T&gt;using func_t &#x3D; void(*)(T, T)&#x2F;&#x2F;使用func_t模板func_t&lt;int&gt; xx_2; C++11支持函数模板的默认模板参数 在C++98/03标准中，类模板可以有默认的模板参数，如下： 12345template &lt;typename T, typename U&#x3D;int, U N &#x3D; 0&gt;struct Foo&#123; &#x2F;&#x2F;...&#125;; 但是却不支持函数的默认模板餐宿 12345template &lt;typename T&#x3D;int&gt; &#x2F;&#x2F;error in C++98&#x2F;03:default template argumentsvoid fun()&#123; &#x2F;&#x2F;...&#125; 但是在C++11中这一限制被解除了。 函数模板的默认模板参数在使用规则上和其他的默认参数函数也有一些不同，它没有必须写在参数表最后的限制，甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。 12345678910111213template &lt;typename R &#x3D; int, typename U&gt;R func(U val)&#123; return val;&#125;int main()&#123; func(97); &#x2F;&#x2F;R&#x3D;int, U&#x3D;int func&lt;char&gt;(97); &#x2F;&#x2F;R&#x3D;char , U&#x3D;char func&lt;double, int&gt;; &#x2F;&#x2F;R&#x3D;double, U&#x3D;int return 0;&#125; C++11列表初始化（统一了初始化方式） C++98/03中的对象初始化 1234567891011121314151617181920212223&#x2F;&#x2F;初始化列表int i_arr[3] &#x3D; &#123;1,2,3&#125;; &#x2F;&#x2F;普通数组struct A&#123; int x; struct B &#123; int i; int j; &#125;b;&#125;a &#x3D; &#123;1, &#123;2,3&#125;&#125;; &#x2F;&#x2F;POD类型(plain old data)&#x2F;&#x2F;拷贝初始化(copy-initialization)int i &#x3D; 0;class Foo&#123;public: Foo(int)&#123;&#125;&#125;foo&#x3D;123; &#x2F;&#x2F;徐娅萍拷贝构造函数&#x2F;&#x2F;直接初始化（direct-initialization）int j(0);Foo bar(123); C++11 lambda匿名函数用法 定义 1234[外部变量访问方式说明符](参数)mutable noexcept&#x2F;throw -&gt; 返回值类型&#123; 函数体;&#125;; [外部变量访问方式说明符] 1[]方括用于向编译器表明当前是一个lambda表达式，其不能被省略。在方括号内部，可以注明当前lambda函数的函数体中可以使用哪些&quot;外部变量&quot; (参数) 1和普通函数的定义一样，lambda匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同()小括号一起省略； mutable 12此关键字可以省略，如果使用则之前的()小括号将不能省略(参数个数可以为0)。默认情况下，对于以值传递方式引入的外部变量，不允许在lambda表达式内部修改它们的值(可以理解为这部分变量都是const常量)。而如果想修改它们，就必须使用mutable关键字。注意：对于以值传递方式引入的外部变量，lambda表达式修改的是拷贝的那一份，并不会修改真正的外部变量； noexcept/throw() 123可以省略，如果使用，在之前的()小括号将不能省略(参数个数可以为0).默认情况下，lambda函数的函数体中可以抛出任何类型的异常。而标注noexcept关键字，则表示函数体内不会抛出任何异常；使用throw()可以指定lambda函数内部可以抛出的异常类型。如果lambda函数标有noexcept而函数体内抛出了异常，又或者使用throw()限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用try-catch捕获，会导致程序执行失败。 -&gt; 返回值类型 1指明lambda匿名函数的返回值类型。值得一提的是，如果lambda函数体内只有一个return语句，或者该函数返回void，则编辑器可以自行推断出返回类型，此情况可以直接忽略 &#39;-&gt;返回值类型&#39; 函数体 1和普通函数一样，lambda匿名函数包含的内部代码都放置在函数体中，该函数体除了可以使用指定传递进来的参数之外，还以可以使用指定的外部变量义级全局范围内的所有全局变量。 lambda匿名函数中的[外部变量] 外部变量格式 功能 [] 空方括号白哦是当前lambda匿名函数中不导入任何外部变量 [=] 只有一个 = 等号，表示以值传递的方式导入所有外部变量 [val1, val2,…] 表示以值传递的方式导入val1，val2等指定的外部变量，同时多个变量之间没有先后次序 [&amp;val1, &amp;val2,…] 表示以引用传递的方式导入val1，val2等指定的外部变量，多个变量之间没有先后次序 [val,&amp;val2,…] 以上两种方式还可以混合使用，变量之间内有前后次序 [=,&amp;val1,…] 表示除val1以引用传递的方式导入外，其他外部变量都以值传递的方式导入。 this 表示以值传递的方式导入当前的this指针 C++11非受限联合体(union) POD(Plain Old Data)的特征 没有用户自定义的构造函数，析构函数，拷贝构造函数和移动构造函数。 不能包含虚函数和虚基类。 不能包含虚函数和虚基类。 非静态成员必须声明为public。 类中的第一个非静态成员的类型与其基类不同 在类或者结构体继承时，满足一下两种情况之一： 派生类中有非静态成员，且只有一个仅包含静态成员的基类； 基类有非静态成员，而派生类没有非静态成员。 此外，所有兼容C语言的数据类型都是POD类型（struct， union等不能违背上述规则） C++11允许联合体有静态成员 非受限联合体的复制注意事项C++11规定，如果非首先联合体内有一个非POD的成员，而该成员拥有自定义的析构函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数，拷贝赋值操作符义级析构函数等，也将被删除。 这条规则可能导致对象构造失败，如下 1234567891011121314#include &lt;string&gt;using namespace std;union U&#123; string s; int n;&#125;int main()&#123; U u; &#x2F;&#x2F;构造失败，因为U的构造函数被删除 return 0;&#125; 在上面的例子中，因为string类拥有自定义的构造函数，所以U的构造函数被删除；定义U的类型变量u需要调用默认构造函数，所以u也就无法定义成功。 解决上面问题的一般需要用到 placement new，代码如下： 123456789101112131415161718#include &lt;string&gt;using namespace std;union U&#123; string s; int n;public: U() &#123;new(&amp;s) string;&#125; ~U() &#123;s.~string();&#125;&#125;;int main()&#123; U u; &#x2F;&#x2F;构造失败，因为U的构造函数被删除 return 0;&#125; placement new1placement new 是new关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆(heap)上生成对象。相应地，将常见的new的用法称为operator new，它只能在heap上生成对象。 placement new的语法格式如下 1new(address) ClassConstruct(...) address表示已有内存的地址，该内存可以在栈上，也可以在堆上；ClassConstruct(…)表示调用类的构造函数，如果构造哈数没有参数，也可以省略括号。 placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在address指定的内存中。 非受限联合体的匿名声明和“枚举式类”匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下: 123union U&#123; union&#123;int x;&#125;; &#x2F;&#x2F;此联合体为匿名联合体&#125;; 同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为“枚举式类”，示例如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstring&gt;using namespace std;class Student&#123;public: Student(bool g, int a): gender(g), age(a)&#123;&#125; bool gender; int age;&#125;;class Singler&#123;public: enum Type &#123;STUDENT, NATIVE, FOREIGER&#125;; Singer(bool g, int a) : s(g,a)&#123;t &#x3D; STUDENT;&#125; Singer(int i): id(i)&#123;t &#x3D; NATIVE;&#125; Singer(const char *n, int s) &#123; int size &#x3D; (s &gt; 9) ? 0 :s; memcpy(name,n,size); name[s] &#x3D; &#39;\\0&#39;; t &#x3D; FOREIGER; &#125; ~Singer()&#123;&#125;private: Type t; union &#123; Student s; int id; char name[10]; &#125;;&#125;;int main() &#123; Singer(true, 13); Singer(310217); Singer(&quot;J Michael&quot;, 9); return 0;&#125; 上面的代码中使用了一个匿名非受限联合体，它作为类Singer的“变长成员”来使用，这样的变长成员给类的编写带来了更大的灵活性。 C++11 for循环(基于范围的循环)详解for循环的格式 123for(表达式 1; 表达式 2; 表达式 3)&#123; &#x2F;&#x2F;循环体&#125; 在C++11中，新增了如下格式的循环 123for (declaration : expression)&#123; &#x2F;&#x2F;循环体&#125; declaration : 表示此处要定义一个变量，该变量的类型为要变量序列中存储元素的类型。在C++11标准中，declaration参数处定义的变量类型可以用auto关键字表示，该关键字可以使编译器自行推导出该变量的数据类型。 expression：表示要遍历的序列，常见的可以为事先定义好的普通数组或者容器，还可以是用 {} 大括号初始化的序列。 在使用新语法格式的for循环遍历某个序列时，如果需要遍历的同时修改序列中元素的值，实现方案是在declaration参数处定义引用形式的变量。 12345678910111213141516#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; char arc[] &#x3D; &quot;abcde&quot;; vector&lt;char&gt;myvector(arc, arc + 5); &#x2F;&#x2F;for循环遍历并修改容器中各个字符的值 for (auto &amp;ch : myvector) &#123; ch++; &#125; &#x2F;&#x2F;for循环遍历输出容器中各个字符 for (auto ch : myvector) &#123; cout &lt;&lt; ch; &#125; return 0;&#125; C++11 constexpr：验证是否为常量表达式C++11 右值引用 引用类型 非常量左值 常量左值 非常量右值 常量右值 使用场景 非常量左值引用 Y N N N 无 常量左值引用 Y Y Y Y 常用于类中构建拷贝构造函数 非常量左值引用 N N Y N 移动语义，完美转发 常量右值引用 N N Y Y 无实际用途 C++11 移动构造函数1移动语义，指的是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的是将其他对象（通常是临时对象）拥有的内存资源“移为己用”。 demo 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class demo&#123;private: &#x2F;* data *&#x2F; int *num;public: demo(&#x2F;* args *&#x2F;) : num(new int(0))&#123; cout &lt;&lt;&quot;construct!&quot; &lt;&lt;endl; &#125; demo(const demo &amp;d):num(new int(*d.num)) &#123; cout &lt;&lt; &quot;copy construct! &quot;&lt;&lt; endl; &#125; demo(demo &amp;&amp;d):num(d.num) &#123; d.num &#x3D; NULL; cout &lt;&lt; &quot;move construct!&quot; &lt;&lt;endl; &#125; ~demo() &#123; cout &lt;&lt; &quot;class destruc!&quot; &lt;&lt;endl; &#125;&#125;;demo get_demo()&#123; return demo();&#125;int main()&#123; demo a &#x3D; get_demo(); return 0;&#125; C++11 move()函数：将左值强制转换为右值 移动构造函数的调用时机是：用同类的右值对象初始化新对象。 move() 函数的语法格式 1move(arg) arg表示指定的左值对象。该函数会返回arg对象的右值形式。 C++11 完美转发及实现方法 完美转发 1完美转发指的是函数模板可以将自己的参数“完美”地转发给内部调用的其他函数。所谓完美，及不仅能准确地转发参数的值，还能保证被转发参数的左右值属性不变。 nullptr 是nullptr_t 类型的右值常量，专用于初始化空类型指针。 C++11 shared_ptr智能指针12所谓智能指针，可以从字面上理解为“智能”的指针。具体来讲，智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存。也就是说，使用智能指针可以很好的避免“忘记释放内存而导致内存泄漏”问题文献。 shared_ptr 智能指针 123456智能指针都是以类模板的方式实现，shared_ptr&lt;T&gt; (T表示指针指向的具体数据类型) 使用需要包含如下两行代码#include &lt;memory&gt;using namespace std;多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。 shared_ptr智能指针的创建 1234std::shared_ptr&lt;int&gt; p1 ; &#x2F;&#x2F;不传入任何实参std::shared_ptr&lt;int&gt; p2(nullptr); &#x2F;&#x2F;传入空指针nullptrstd::shared_ptr&lt;int&gt; p3(new int(10)); &#x2F;&#x2F;std::shared_ptr&lt;int&gt; p4 &#x3D; std::make_shared&lt;int&gt;(10); shared_ptr 提供又相应的拷贝构造函数和移动构造函数。 12345678910&#x2F;&#x2F;调用拷贝构造函数std::shared_ptr&lt;int&gt; p4(p3);&#x2F;&#x2F;或者 std::shared_ptr&lt;int&gt; p4 &#x3D; p3;&#x2F;&#x2F;调用移动构造函数std::shared_ptr&lt;int&gt; p5(std::move(p4)); &#x2F;&#x2F;或者 std::shared_ptr&lt;int&gt; p5 &#x3D; std::move(p4);p3 和 p4 都是 shared_ptr 类型的智能指针，因此可以用 p3 来初始化 p4，由于 p3 是左值，因此会调用拷贝构造函数。需要注意的是，如果 p3 为空智能指针，则 p4 也为空智能指针，其引用计数初始值为 0；反之，则表明 p4 和 p3 指向同一块堆内存，同时该堆空间的引用计数会加 1.而对于 std::move(p4) 来说，该函数会强制将 p4 转换成对应的右值，因此初始化 p5 调用的是移动构造函数。另外和调用拷贝构造函数不同，用 std::move(p4) 初始化 p5，会使得 p5 拥有了 p4 的堆内存，而 p4 则变成了空智能指针。 自定义shared_ptr智能指针的释放规则 12345678&#x2F;&#x2F;指定 default_delete 作为释放规则std::shared_ptr&lt;int&gt; p6(new int[10], std::default_delete&lt;int[]&gt;());&#x2F;&#x2F;自定义释放规则void deleteInt(int*p) &#123; delete []p;&#125;&#x2F;&#x2F;初始化智能指针，并自定义释放规则std::shared_ptr&lt;int&gt; p7(new int[10], deleteInt); shared_ptr&lt;T&gt;模板提供的成员方法 成员方法名 功能 operator=() 重载赋值号，使得同一类型的 shared_ptr 智能指针可以相互赋值。 operator*() 重载*号，夺取当前shared_ptr智能指针对象指向的数据 operator-&gt;() 重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。 swap() 交换 2 个相同类型 shared_ptr 智能指针的内容。 reset() 当函数没有实参时，该函数会使当前 shared_ptr 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的 shared_ptr 对象会获得该存储空间的所有权，并且引用计数的初始值为 1。 get() 获得 shared_ptr 对象内部包含的普通指针。 use_count() 返回同当前 shared_ptr 对象（包括它）指向相同的所有 shared_ptr 对象的数量。 unique() 判断当前 shared_ptr 对象指向的堆内存，是否不再有其它 shared_ptr 对象再指向它。 operator bool() 判断当前 shared_ptr 对象是否为空智能指针，如果是空指针，返回 false；反之，返回 true。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;int main()&#123; &#x2F;&#x2F;构建 2 个智能指针 std::shared_ptr&lt;int&gt; p1(new int(10)); std::shared_ptr&lt;int&gt; p2(p1); &#x2F;&#x2F;输出 p2 指向的数据 cout &lt;&lt; *p2 &lt;&lt; endl; p1.reset();&#x2F;&#x2F;引用计数减 1,p1为空指针 if (p1) &#123; cout &lt;&lt; &quot;p1 不为空&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;p1 为空&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;以上操作，并不会影响 p2 cout &lt;&lt; *p2 &lt;&lt; endl; &#x2F;&#x2F;判断当前和 p2 同指向的智能指针有多少个 cout &lt;&lt; p2.use_count() &lt;&lt; endl; return 0;&#125; C++11 unique_ptr智能指针1作为智能指针的一种，unique_ptr 指针自然也具备“在适当时机自动释放堆内存空间”的能力。和 shared_ptr 指针最大的不同之处在于，unique_ptr 指针指向的堆内存无法同其它 unique_ptr 共享，也就是说，每个 unique_ptr 指针都独自拥有对其所指堆内存空间的所有权。 unique_ptr智能指针的创建 创建空的unique_ptr指针 12std::unique_ptr&lt;int&gt; p1();std::unique_ptr&lt;int&gt; p2(nullptr); 创建 unique_ptr 指针的同时，也可以明确其指向 1std::unique_ptr&lt;int&gt; p3(new int); 基于 unique_ptr 类型指针不共享各自拥有的堆内存 123std::unique_ptr&lt;int&gt; p4(new int);std::unique_ptr&lt;int&gt; p5(p4);&#x2F;&#x2F;错误，堆内存不共享std::unique_ptr&lt;int&gt; p5(std::move(p4));&#x2F;&#x2F;正确，调用移动构造函数 默认情况下，unique_ptr 指针采用 std::default_delete 方法释放堆内存。当然，我们也可以自定义符合实际场景的释放规则。值得一提的是，和 shared_ptr 指针不同，为 unique_ptr 自定义释放规则，只能采用函数对象的方式。 123456789&#x2F;&#x2F;自定义的释放规则struct myDel&#123; void operator()(int *p) &#123; delete p; &#125;&#125;;std::unique_ptr&lt;int, myDel&gt; p6(new int);&#x2F;&#x2F;std::unique_ptr&lt;int, myDel&gt; p6(new int, myDel()); unique_ptr&lt;T&gt;模板类提供的成员方法 成员函数名 功能 operator*() 获取当前 unique_ptr 指针指向的数据。 operator-&gt;() 重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。 operator =() 重载了 = 赋值号，从而可以将 nullptr 或者一个右值 unique_ptr 指针直接赋值给当前同类型的 unique_ptr 指针。 operator 重载了 [] 运算符，当 unique_ptr 指针指向一个数组时，可以直接通过 [] 获取指定下标位置处的数据。 get() 获取当前 unique_ptr 指针内部包含的普通指针。 get_deleter() 获取当前 unique_ptr 指针释放堆内存空间所用的规则。 operator bool() unique_ptr 指针可直接作为 if 语句的判断条件，以判断该指针是否为空，如果为空，则为 false；反之为 true。 release() 释放当前 unique_ptr 指针对所指堆内存的所有权，但该存储空间并不会被销毁。 reset(p) 其中 p 表示一个普通指针，如果 p 为 nullptr，则当前 unique_ptr 也变成空指针；反之，则该函数会释放当前 unique_ptr 指针指向的堆内存（如果有），然后获取 p 所指堆内存的所有权（p 为 nullptr）。 swap(x) 交换当前 unique_ptr 指针和同类型的 x 指针。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;int main()&#123; std::unique_ptr&lt;int&gt; p5(new int); *p5 &#x3D; 10; &#x2F;&#x2F; p 接收 p5 释放的堆内存 int * p &#x3D; p5.release(); cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;判断 p5 是否为空指针 if (p5) &#123; cout &lt;&lt; &quot;p5 is not nullptr&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;p5 is nullptr&quot; &lt;&lt; endl; &#125; std::unique_ptr&lt;int&gt; p6; &#x2F;&#x2F;p6 获取 p 的所有权 p6.reset(p); cout &lt;&lt; *p6 &lt;&lt; endl;; return 0;&#125; C++11 weak_ptr智能指针 weak_ptr指针的创建 创建一个空weak_ptr指针 1std::weak_ptr&lt;int&gt; wp1; 凭借已有的 weak_ptr 指针，可以创建一个新的 weak_ptr 指针 1std::weak_ptr&lt;int&gt; wp2 (wp1); weak_ptr 指针更常用于指向某一 shared_ptr 指针拥有的堆内存，因为在构建 weak_ptr 指针对象时，可以利用已有的 shared_ptr 指针为其初始化. 12std::shared_ptr&lt;int&gt; sp (new int);std::weak_ptr&lt;int&gt; wp3 (sp); wp3 指针和 sp 指针有相同的指针。再次强调，weak_ptr 类型指针不会导致堆内存空间的引用计数增加或减少。 weak_ptr模板类提供的成员方法 成员方法 功能 operator=() 重载 = 赋值运算符，是的 weak_ptr 指针可以直接被 weak_ptr 或者 shared_ptr 类型指针赋值。 swap(x) 其中 x 表示一个同类型的 weak_ptr 类型指针，该函数可以互换 2 个同类型 weak_ptr 指针的内容。 reset() 将当前 weak_ptr 指针置为空指针。 use_count() 查看指向和当前 weak_ptr 指针相同的 shared_ptr 指针的数量。 expired() 判断当前 weak_ptr 指针为否过期（指针为空，或者指向的堆内存已经被释放）。 lock() 如果当前 weak_ptr 已经过期，则该函数会返回一个空的 shared_ptr 指针；反之，该函数返回一个和当前 weak_ptr 指向相同的 shared_ptr 指针。","categories":[{"name":"C++","slug":"C","permalink":"https://yankaiguo.github.io/categories/C/"}],"tags":[]},{"title":"基础篇、到底应该怎么理解\"平均负载\"","slug":"什么是平均负载？","date":"2020-02-08T04:56:26.191Z","updated":"2020-10-09T14:04:46.121Z","comments":true,"path":"2020/02/08/什么是平均负载？/","link":"","permalink":"https://yankaiguo.github.io/2020/02/08/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%EF%BC%9F/","excerpt":"","text":"什么是平均负载？正确定义：平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和CPU使用率并没有直接关系。 错误定义：单位时间内的CPU使用率下面先介绍一下可运行状态进程和不可中断状态进程：1. 可运行状态进程 可运行状态状态的进程，是指正在使用CPU或者正在等待CPU的进程。 比如使用ps命令看到的，处于R状态（Running 或 Runnable）的进程。 2. 不可中断状态进程 不可中断状态的进程是正处于内核态关键流程中的进程，并且这些流程是不可打断的。不可中断状态实际上是系统对进程和硬件设备的一种保护机制。 比如最常见的是等待硬件设备的I/O响应，也就是我们在ps命令中看到的D状态（Uninterruptible Sleep，也称为Disk Sleep）的进程。 3.过载经验值 平均负载高于CPU核数70%的时候 相关指令CPU核数1. lscpu 12345678910111213141516171819202122232425$ lscpuArchitecture: x86_64CPU op-mode(s): 32-bit, 64-bitByte Order: Little EndianCPU(s): 8On-line CPU(s) list: 0-7Thread(s) per core: 1Core(s) per socket: 8Socket(s): 1NUMA node(s): 1Vendor ID: GenuineIntelCPU family: 6Model: 142Model name: Intel(R) Core(TM) i7-8565U CPU @ 1.80GHzStepping: 12CPU MHz: 1991.999BogoMIPS: 3983.99Virtualization: VT-xHypervisor vendor: VMwareVirtualization type: fullL1d cache: 32KL1i cache: 32KL2 cache: 256KL3 cache: 8192KNUMA node0 CPU(s): 0-7 2. grep ‘model name’ /proc/cpuinfo | wc -l 12$ grep &#39;model name&#39; &#x2F;proc&#x2F;cpuinfo | wc -l8 显示负载1. uptime 12$ uptime 08:45:52 up 1 day, 10:29, 2 users, load average: 0.44, 0.10, 0.03 load average：显示的顺序是最近1分钟，5分钟，15分钟的平均负载情况。通过观察趋势，判定平均负载是否异常。 1. top 123456$ toptop - 08:46:50 up 1 day, 10:30, 2 users, load average: 0.21, 0.09, 0.03Tasks: 396 total, 2 running, 298 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.9 us, 0.4 sy, 0.0 ni, 98.6 id, 0.0 wa, 0.0 hi, 0.1 si, 0.0 stKiB Mem : 2006004 total, 149252 free, 1172820 used, 683932 buff&#x2F;cacheKiB Swap: 1942896 total, 1430896 free, 512000 used. 637672 avail Mem 3. watch -d uptime-d 会高亮显示变化的区域 4. stress 压测命令 1234--cpu n cpu压测选项--i n io压力测试选项， -c n 进程数压测选项-timeout 执行时间 5. mpstat多核CPU 性能分析工具 ，mpstat -P ALL :监视所有CPU 6. pidstat进程性能分析工具， -u 显示cpu利用率 平均负载和cpu使用的区别CPU使用率CPU使用率是指cpu繁忙情况的统计 情况1：CPU密集型进程， CPU使用率和平均负载基本一致 情况2：IO密集型进程， 平均负载升高，CPU使用率不一定升高 情况3：大量等待CPU的进程调度，平均负载升高，CPU使用率也升高 平均负载升高时，如何调优CPU密集型进程case mpstat -p ALL 5: -P ALL 表示监控所有CPU， 5表示每5秒刷新一次数据，观察是否有某个CPU很高， 但iowait很低。 pidstat -u 5 1: 每5秒输出一组数据，观察哪个进程%cpu很高，但是%wait很低， 极有可能就是这个进程导致cpu飙升。IO密集型进程case mpstat -P ALL 5 : 观察是否某个cpu的%iowait很高，同时%usr也较高 pidstat -u 5 1 : 观察哪个进程%wait较高，同时%cpu也较高大量进程case pidstat -u 5 1 : 观察那些%wait 较高的进程是否有很多。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://yankaiguo.github.io/categories/Linux/"}],"tags":[]}],"categories":[{"name":"C++","slug":"C","permalink":"https://yankaiguo.github.io/categories/C/"},{"name":"Linux","slug":"Linux","permalink":"https://yankaiguo.github.io/categories/Linux/"}],"tags":[]}