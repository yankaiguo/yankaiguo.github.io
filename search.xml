<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式之设计原则</title>
    <url>/4a7ab732.html</url>
    <content><![CDATA[<h1 id="SOLID-原则"><a href="#SOLID-原则" class="headerlink" title="SOLID 原则"></a>SOLID 原则</h1><p>SOLID原则并非单纯的一个原则，而是由五个设计原则组成，它们分别是<code>单一职责原则</code>,<code>开闭原则</code>，<code>里氏替换原则</code>，<code>接口隔离原则</code>和<code>依赖原则</code>, 依次对应SOLID中的S、O、L、I、D这五个字母。</p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则的英文是<code>Single Responsibility Principle</code>，缩写为SRP. 英文描述为<code>A Class or module should have a single responsibility</code>.翻译成中文是<code>一个类或模块只负责完成一个职责（或者功能）</code>。</p>
<p>在实际编程中，可以参考如下几条判断原则来评判代码是否符合单一职责原则。</p>
<ul>
<li>类中的代码行数，函数或属性过多，会影响代码的可读性和可维护性，这时我们要考虑对类进行拆分</li>
<li>类依赖的其他类过多，或者依赖类的其它类过多， 不符合高内聚，低耦合的设计思想，这时我们要考虑对类进行拆分</li>
<li>私有方法过多，这是我们需要考虑是否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提供代码的复用性</li>
<li>比较难给类起一个合适名字，很难用一个业务名词概括，或者智能用一些笼统的Manager，Context之类的词语来命名，这就说明类的职责定义可能不够清晰</li>
<li>类中大量的方法都集中操作类中的某几个属性。</li>
</ul>
<p>单一职责原则通过避免设计大而全的类，避免将不相关的额功能耦合在起义，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其它类也会变少，减少了代码的耦合性。以此来实现代码的高内聚，低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码得可维护性。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则的英文全称是<code>Open Closed Principle</code>,简写为OCP。它的英文描述为:<code>software entities(modules,classes,functions,etc) should be open for extension,but closed for modification</code>。中文描述是：<code>软件实体(模块，类，方法等)应该对扩展开放，对修改关闭</code>。详细描述为: <code>添加一个新的功能应该是，在已有代码基础上扩展代码(新增模块，类，方法等)，而非修改已有代码(修改模块，类，方法等)</code>。</p>
<h3 id="如何做到”对扩展开放，对修改关闭“？"><a href="#如何做到”对扩展开放，对修改关闭“？" class="headerlink" title="如何做到”对扩展开放，对修改关闭“？"></a>如何做到”对扩展开放，对修改关闭“？</h3><p>我饿们要时刻具备扩展意识，抽象意识，封装意识。在写代码的时候，要多花点时间思考以下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构，做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>里氏替换原则的英文全称是<code>Liskov Substitution Principle</code>,缩写为LSP。这个原则最早是在1986年由Barbara Liskov 提出，他是这么描述这条原则的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program.</span><br></pre></td></tr></table></figure>

<p>在1996年，Robert Martin 在他的SOLID原则中，重新描述了这个原则，英文原话是这样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Functions that use pointers of references to base class must be able to use objects of derived classes without knowing it.</span><br></pre></td></tr></table></figure>

<p>综合两者的描述，我们可以描述为：<code>子类对象(object of subtype /derived class)能够替换程序(program)中父类对象(object of base/parent class)出现的任何地方，并且保证原来程序的逻辑行为(behavior)不变及正确性不被破坏</code>。</p>
<h3 id="哪些代码明显违背了LSP"><a href="#哪些代码明显违背了LSP" class="headerlink" title="哪些代码明显违背了LSP?"></a>哪些代码明显违背了LSP?</h3><ul>
<li>子类违背父类声明要实现的功能。</li>
<li>子类违背父类对输入，输出，异常的约定。</li>
<li>子类违背父类注释中所罗列的任何特殊说明。</li>
</ul>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则的英文是<code>Interface Segregation Principle</code>,缩写为<code>ISP</code>.Robert Martin在SOLID原则的定义如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Clients should not be forced to depend upon interface that they do not use.</span><br></pre></td></tr></table></figure>

<p>直译成中文就是：<code>客户端不应该被迫依赖它不需要的接口</code>。其中的“客户端”，可以理解为接口的调用者或者使用者。</p>
<p>实际上，<code>接口</code>这个名词可以用在很多场合。在软件开发中，我们既可以把它看作一组抽象的约定，也可以具体指系统与系统之间的API接口，还可以指面向对象编程语言中的接口。</p>
<p>我们可以把”接口”理解为下面三种东西：</p>
<ul>
<li>一组API接口集合</li>
<li>单个API接口或函数</li>
<li>OOP中的接口概念</li>
</ul>
<h3 id="把“接口”理解为一组API-接口集合"><a href="#把“接口”理解为一组API-接口集合" class="headerlink" title="把“接口”理解为一组API 接口集合"></a>把“接口”理解为一组API 接口集合</h3><p>我们把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。</p>
<h3 id="把“接口”理解为单个API接口或者函数"><a href="#把“接口”理解为单个API接口或者函数" class="headerlink" title="把“接口”理解为单个API接口或者函数"></a>把“接口”理解为单个API接口或者函数</h3><p>接口隔离原则跟单一职责原则有点类似，不过稍微有点区别。单一职责原则针对的是模块，类，接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>
<h3 id="把“接口”理解为OOP中的接口概念"><a href="#把“接口”理解为OOP中的接口概念" class="headerlink" title="把“接口”理解为OOP中的接口概念"></a>把“接口”理解为OOP中的接口概念</h3><p>TODO</p>
<h2 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h2><h3 id="控制反转-IOC"><a href="#控制反转-IOC" class="headerlink" title="控制反转(IOC)"></a>控制反转(IOC)</h3><p>框架提供了一个可扩展的代码骨架，用来组装对象，管理整个执行流程。程序员进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</p>
<p>这里的“控制”指的是对程序流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。</p>
<h3 id="依赖注入-DI"><a href="#依赖注入-DI" class="headerlink" title="依赖注入(DI)"></a>依赖注入(DI)</h3><p>依赖注入跟控制反转相反，它是一种具体的编程技巧。依赖注入的英文翻译是<code>Dependency Injecrtion</code>,缩写为DI.</p>
<p>依赖注入：不通过new()的方式在类内部创建依赖对象，而是将依赖的类对象在外部创建好之后，通过构造函数，函数参数等方式传递(注入)给类使用。</p>
<p>通过依赖注入的方式将以来的类对象传递进来，可以提高代码的扩展性，可以灵活地替换依赖的类。</p>
<h3 id="依赖注入框架-DI-Framework"><a href="#依赖注入框架-DI-Framework" class="headerlink" title="依赖注入框架(DI Framework)"></a>依赖注入框架(DI Framework)</h3><p>在实际的软件开发中，一些项目可能会涉及几十，上百，甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建来依赖的注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。这个框架就是“依赖注入框架”。</p>
<h3 id="依赖反转原则-DIP"><a href="#依赖反转原则-DIP" class="headerlink" title="依赖反转原则(DIP)"></a>依赖反转原则(DIP)</h3><p>依赖反转原则的英文是<code>Dependency Inversion Principle</code>，缩写为DIP。中文翻译有时候也叫依赖倒置原则。英文描述为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">High-level modules shouldn&#39;t depend on low-level modules.Both modules should depend on abstractions. In addition,abstractions shouldn&#39;t depend on details. Details depend on abstractions.</span><br></pre></td></tr></table></figure>

<p>翻译为中文，大概意思是：高层模块(high-level modules)不要依赖底层模块(low-level)。高层模块和底层模块应该通过抽象(abstraction)来相互依赖，除此之外，抽象(abstractions)不要依赖具体实现细节(details)，具体实现细节(details)依赖抽象(abstractions)。</p>
<h1 id="KISS-原则"><a href="#KISS-原则" class="headerlink" title="KISS 原则"></a>KISS 原则</h1><p>KISS原则的英文描述有好几个版本，比如下面几个</p>
<ul>
<li>Keep It Simple and Stupid</li>
<li>Keep It Short and Simple</li>
<li>Keep It Simple and Straightforward</li>
</ul>
<p>不过要表达的原则其实差不多，翻译成中文就是：尽量保持简单。</p>
<h3 id="如何写出满足KISS原则的代码？"><a href="#如何写出满足KISS原则的代码？" class="headerlink" title="如何写出满足KISS原则的代码？"></a>如何写出满足KISS原则的代码？</h3><ul>
<li>不要使用同时可能不懂的技术实现代码。比如使用复杂的正则表达式，或者一些编程语言中过于高级的语法等。</li>
<li>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出bug的概率会更高，维护的成本也比较高。</li>
<li>不要过度优化。不要过度使用一些奇技淫巧(比如，位运算代替算术，复杂的条件语句代替if-else，使用一些过于底层的函数等)来优化代码，牺牲代码的可读性。</li>
</ul>
<h1 id="YAGNI原则"><a href="#YAGNI原则" class="headerlink" title="YAGNI原则"></a>YAGNI原则</h1><p>YANNI原则的英文是<code>You Ain&#39;t Gonna Need It</code>。直译就是:<code>你不会需要它</code>.在软件开发中，它的意思是：<code>不要去设计当前用不到的功能；不要去编写当前用不到的代码。</code>其核心思想是– 不要做过度设计。</p>
<h1 id="DRY原则"><a href="#DRY原则" class="headerlink" title="DRY原则"></a>DRY原则</h1><p>DRY的英文描述为：Don’t Repeat Yourself.</p>
<h1 id="LOD原则"><a href="#LOD原则" class="headerlink" title="LOD原则"></a>LOD原则</h1><p>迪米特法则的英文是<code>Law of Demeter</code>,缩写是LOD。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11标准</title>
    <url>/cbc30407.html</url>
    <content><![CDATA[<h1 id="C-11是什么，C-11标准的由来"><a href="#C-11是什么，C-11标准的由来" class="headerlink" title="C++11是什么，C++11标准的由来"></a>C++11是什么，C++11标准的由来</h1><h1 id="C-11-auto类型推导"><a href="#C-11-auto类型推导" class="headerlink" title="C++11 auto类型推导"></a>C++11 auto类型推导</h1><h2 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h2><p>C++11 使用auto来做自动类型推导，使用了auto关键字之后，编译器会在编译期间自动推导出变量的类型。</p>
<h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> name = value</span><br></pre></td></tr></table></figure>

<ul>
<li>auto 仅仅是个占位符，在编译器期间它会被真正的类型所替代。</li>
</ul>
<h2 id="auto的高级用法"><a href="#auto的高级用法" class="headerlink" title="auto的高级用法"></a>auto的高级用法</h2><ul>
<li><p>auto除了可以独立使用，还可以和某些具体类型混合使用，这样auto表示的就是”半个”类型，而不是完整的类型。例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> *p1 = &amp;x;   <span class="comment">//p1为int * , auto 推导为int</span></span><br><span class="line"><span class="keyword">auto</span> p2 = &amp;x; 	<span class="comment">//p2为int* ，auto推导为int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r1 = x; 	<span class="comment">//r1为int&amp; , auto 推导为int</span></span><br><span class="line"><span class="keyword">auto</span> r2 = r1;	<span class="comment">//r1 为int， auto推导为int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>auto与const的结合</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> n = x; 		<span class="comment">//n为const int， auto被推导为int</span></span><br><span class="line"><span class="keyword">auto</span> f = n;  			<span class="comment">//f为const int， auto 被推导为int (const 属性为抛弃)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;r1 = x; 	<span class="comment">//r1为const int&amp; 类型，auto被推导为int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r2 = r1; 			<span class="comment">//r1 时const int&amp; 类型，auto被推导为const int类型。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>当类型不为引用时，auto的推导结果将不保留表达式的const属性</li>
<li>当类型为引用时，auto的推导结果将保留表达式的const属性。</li>
</ul>
<h2 id="auto的限制"><a href="#auto的限制" class="headerlink" title="auto的限制"></a>auto的限制</h2><ol>
<li><p>auto不能再函数的参数中使用。</p>
</li>
<li><p>auto关键字不能作用于类的非静态成员变量(也就是没有static关键字修饰的成员变量)中。</p>
</li>
<li><p>auto关键字不能定义数组，例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> url[] = <span class="string">"http://c.biancheng.net/"</span>;</span><br><span class="line"><span class="keyword">auto</span> str[] = url;	<span class="comment">//url为数组，所以不能使用auto</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>auto不能作用于模板参数</p>
</li>
</ol>
<h2 id="auto的应用"><a href="#auto的应用" class="headerlink" title="auto的应用"></a>auto的应用</h2><ul>
<li>auto定义stl的迭代器</li>
<li>auto用于泛型编程</li>
</ul>
<h1 id="C-11-decltype类型推导"><a href="#C-11-decltype类型推导" class="headerlink" title="C++11 decltype类型推导"></a>C++11 decltype类型推导</h1><h2 id="功能说明-1"><a href="#功能说明-1" class="headerlink" title="功能说明"></a>功能说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">decltype是C++11新增的一个关键字，它和auto的功能一样，都用来在编译时进行自动类型推导。</span><br></pre></td></tr></table></figure>

<h2 id="语法说明-1"><a href="#语法说明-1" class="headerlink" title="语法说明"></a>语法说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto varname &#x3D; value;</span><br><span class="line">decltype(exp) varname &#x3D; value; &#x2F;&#x2F;varname表示变量名，value表示赋给变量的值，exp表示一个表达式。</span><br><span class="line">decltype根据exp表达式推导出变量的类型，跟&quot;&#x3D;&quot;右边的value没有关系。</span><br></pre></td></tr></table></figure>

<ul>
<li>auto 要求变量必须初始化，而decltype不要求。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 0;</span><br><span class="line">decltype(a) b &#x3D; 1; 	&#x2F;&#x2F;b 被推导成了int</span><br><span class="line">decltype(10.8) x &#x3D; 5.5;	&#x2F;&#x2F;x 被推到成了double</span><br><span class="line">decltype(x + 10) y ; 	&#x2F;&#x2F;y 被推导成了double</span><br></pre></td></tr></table></figure>

<h2 id="decltype推导规则"><a href="#decltype推导规则" class="headerlink" title="decltype推导规则"></a>decltype推导规则</h2><ul>
<li>如果exp是一个不被括号<code>()</code>包围的表达式，或者是一个类成员访问表达式，或者是一个单独的表达式，或者是一个单独的变量，那么decltype(exp)的类型就和exp一致。</li>
<li>如果exp是函数调用，那么decltype(exp) 的类型就和函数返回值的类型一致。</li>
<li>如果exp是一个左值，或者被括号<code>()</code>包围，那么decltype(exp)的类型就是exp的引用；假设exp的类型为T,那么decltype(exp)的类型就是T&amp;.</li>
</ul>
<h3 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> total;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">float</span> scores;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Student::total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> &amp;r = n;</span><br><span class="line">	Student stu;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">decltype</span>(n) a = n;		<span class="comment">//n 为int类型，a被推导为int类型</span></span><br><span class="line">	<span class="keyword">decltype</span>(r) b = n;		<span class="comment">//r为const int&amp; 类型，b被推导为const int&amp; 类型</span></span><br><span class="line">	<span class="keyword">decltype</span>(Student::total) c= <span class="number">0</span>; 	<span class="comment">//total 为类Student的一个int类型的成员变量，c被推导为int类型</span></span><br><span class="line">	<span class="keyword">decltype</span>(stu.name) url = <span class="string">"http://c.biancheng.net/cplus/"</span>; <span class="comment">//name为类Student的一个string类型变量，url被推导为string类型</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例2：-exp为函数调用"><a href="#实例2：-exp为函数调用" class="headerlink" title="实例2： exp为函数调用"></a>实例2： exp为函数调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;函数声明</span><br><span class="line">int&amp; func_int_r(int, char); &#x2F;&#x2F;返回类型为int &amp;</span><br><span class="line">int&amp;&amp; func_int_rr(void);	&#x2F;&#x2F;返回类型为int &amp;&amp;</span><br><span class="line">int func_int(double);		&#x2F;&#x2F;返回类型为int</span><br><span class="line"></span><br><span class="line">const int&amp; fun_cint_r(int,int,int);	&#x2F;&#x2F;返回值为const int&amp;</span><br><span class="line">const int&amp;&amp; fun_cint_rr(void);		&#x2F;&#x2F;返回类型为const int&amp;&amp;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;decltype 类型推导</span><br><span class="line">int n &#x3D; 100;</span><br><span class="line">decltype(func_int_r(100,A)) a &#x3D; n;	&#x2F;&#x2F;a 的类型为 int&amp;</span><br><span class="line">decltype(func_int_rr()) b &#x3D; 0;		&#x2F;&#x2F;b的类型为 int&amp;&amp;</span><br><span class="line">decltype(func_int(10.5)) c &#x3D; 0;		&#x2F;&#x2F;c的类型为 int</span><br><span class="line"></span><br><span class="line">decltype(fun_cint_r(1,2,3)) x &#x3D; n; 	&#x2F;&#x2F;x的类型为 const int&amp;</span><br><span class="line">decltype(fun_cint_rr()) y &#x3D; 0; 		&#x2F;&#x2F;y的类型为 const int&amp;&amp;</span><br></pre></td></tr></table></figure>

<h3 id="实例3-：exp是左值，或者被-包围"><a href="#实例3-：exp是左值，或者被-包围" class="headerlink" title="实例3 ：exp是左值，或者被()包围"></a>实例3 ：exp是左值，或者被<code>()</code>包围</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">	int x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	const Base obj;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;带有括号的表达式</span><br><span class="line">	decltype(obj.x) a &#x3D; 0; 	&#x2F;&#x2F;obj.x为类的成员访问表达式，符合推导规则1，a的类型为int</span><br><span class="line">	decltype((obj.x)) b &#x3D; a; 	&#x2F;&#x2F;obj.x 带有括号，符合推导规则三，b的类型类型为 int&amp;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;加法表达式</span><br><span class="line">	int n&#x3D;0, m &#x3D; 0;</span><br><span class="line">	decltype(m+n) c &#x3D; 0; 	&#x2F;&#x2F;m+n得到一个右值，符合推到规则一，所以推导结果为int</span><br><span class="line">	decltype(n&#x3D;n+m) d &#x3D; c;	&#x2F;&#x2F;n&#x3D;n+m得到一个左值，符号推导规则三，所以推导结果为int&amp;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="decltype-的实际应用"><a href="#decltype-的实际应用" class="headerlink" title="decltype 的实际应用"></a>decltype 的实际应用</h2><ul>
<li>推导非静态成员的类型</li>
</ul>
<h1 id="C-11-auto和decltype的区别"><a href="#C-11-auto和decltype的区别" class="headerlink" title="C++11 auto和decltype的区别"></a>C++11 auto和decltype的区别</h1><h2 id="语法格式的区别"><a href="#语法格式的区别" class="headerlink" title="语法格式的区别"></a>语法格式的区别</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto varname &#x3D; value;			&#x2F;&#x2F;auto的语法格式</span><br><span class="line">decltype(exp) varname[&#x3D;value];	&#x2F;&#x2F;decltype的语法格式</span><br></pre></td></tr></table></figure>

<h2 id="对cv限定符的处理"><a href="#对cv限定符的处理" class="headerlink" title="对cv限定符的处理"></a>对cv限定符的处理</h2><ul>
<li><p>[cv限定符]是const 和volatile关键字的统称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const 关键字用来表示数据是只读的，页就是不能被修改</span><br><span class="line">voltile 和const 是相反的，它用来表示数据是可变的，易变的，目的是不让CPU将数据缓存到寄存器，而是从原始的内存中读取。</span><br></pre></td></tr></table></figure>
</li>
<li><p>decltype会保留cv限定符，而auto有可能会去掉cv限定符。（当推导类型不是指针或引用时，会去掉cv限定符）</p>
</li>
</ul>
<h2 id="对引用的处理"><a href="#对引用的处理" class="headerlink" title="对引用的处理"></a>对引用的处理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当表达式的类型为引用时，auto和decltype的推导规则页不一样，decltype会保留引用类型，而auto会抛弃引用类型，直接推导出它的原始类型。</span><br></pre></td></tr></table></figure>

<h1 id="C-11-返回值类型后置"><a href="#C-11-返回值类型后置" class="headerlink" title="C++11 返回值类型后置"></a>C++11 返回值类型后置</h1><h2 id="功能说明-2"><a href="#功能说明-2" class="headerlink" title="功能说明"></a>功能说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在泛型编程中，可能需要通过参数的运算来得到返回值的类型。</span><br><span class="line">在C++中增加了返回类型后置(trailing-return-type,又称跟踪返回类型)语法，将decltype和auto结合起来完成返回值类型的推导。</span><br></pre></td></tr></table></figure>

<h3 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T, Typename U&gt;</span><br><span class="line">auto add(T t, U u) -&gt; decltype(t+u)</span><br><span class="line">&#123;</span><br><span class="line">	return t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int&amp; foo(int &amp;i);</span><br><span class="line">float foo(float &amp;f)</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">auto func(T&amp; var) -&gt; decltype(foo(var))</span><br><span class="line">&#123;</span><br><span class="line">	return foo(var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回值类型后置语法，是为了解决返回返回值类型依赖于参数而导致难以确定返回值类型的问题，有了这种语法以后，对返回值类型的推导就可以用清晰的方式(直接通过参数做运算)描述出来，而不需要像C++98&#x2F;03那样使用晦涩难懂的写法。</span><br></pre></td></tr></table></figure>

<h1 id="C-11-对模板实例化中连续右尖括号-gt-gt-的改进"><a href="#C-11-对模板实例化中连续右尖括号-gt-gt-的改进" class="headerlink" title="C++11 对模板实例化中连续右尖括号&gt;&gt;的改进"></a>C++11 对模板实例化中连续右尖括号&gt;&gt;的改进</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在C++98&#x2F;03的泛型编程中，模板实例化有一个很繁琐的地方，那就是连续两个右尖括号(&gt;&gt;)会被编译器解释成右移操作符，而不是模板参数表的结束。</span><br></pre></td></tr></table></figure>

<h1 id="C-11-使用using定义别名-替代typedef"><a href="#C-11-使用using定义别名-替代typedef" class="headerlink" title="C++11 使用using定义别名(替代typedef)"></a>C++11 使用using定义别名(替代typedef)</h1><ul>
<li><p>typedef 的用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef unsigned int uint_t</span><br></pre></td></tr></table></figure>
</li>
<li><p>typedef的限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无法重定义一个模板</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>C++11中出现了可以重定义一个模板的语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename Val&gt;</span><br><span class="line">using str_map_t &#x3D; std::map&lt;std::string, Val&gt;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">str_map_t&lt;int&gt; map1</span><br></pre></td></tr></table></figure>
</li>
<li><p>typedef 与using语法对比</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;重定义unsigned int</span><br><span class="line">typedef unsigned int uint_t;</span><br><span class="line">using uint_t &#x3D; unsigned int;</span><br><span class="line">&#x2F;&#x2F;重定义std::map</span><br><span class="line">typedef std::map&lt;std::string, str&gt; map_int_t;</span><br><span class="line">using map_int_t &#x3D; std::map&lt;std::string, int&gt;;</span><br><span class="line">&#x2F;&#x2F;重定义一个函数指针</span><br><span class="line">typedef void(*func_t)(int, int);</span><br><span class="line">using func_t &#x3D; void(*)(int, int);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>using 定义模板别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* C++98&#x2F;03 *&#x2F;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">struct func_t</span><br><span class="line">&#123;</span><br><span class="line">	typedef void(*type)(T, T);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;使用func_t 模板</span><br><span class="line">func_t&lt;int&gt;::type xx_t;</span><br><span class="line"></span><br><span class="line">&#x2F;* C++11 *&#x2F;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">using func_t &#x3D; void(*)(T, T)</span><br><span class="line">&#x2F;&#x2F;使用func_t模板</span><br><span class="line">func_t&lt;int&gt; xx_2;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="C-11支持函数模板的默认模板参数"><a href="#C-11支持函数模板的默认模板参数" class="headerlink" title="C++11支持函数模板的默认模板参数"></a>C++11支持函数模板的默认模板参数</h1><ul>
<li><p>在C++98/03标准中，类模板可以有默认的模板参数，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T, typename U&#x3D;int, U N &#x3D; 0&gt;</span><br><span class="line">struct Foo</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是却不支持函数的默认模板餐宿</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&#x3D;int&gt; &#x2F;&#x2F;error in C++98&#x2F;03:default template arguments</span><br><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在C++11中这一限制被解除了。</p>
</li>
<li><p>函数模板的默认模板参数在使用规则上和其他的默认参数函数也有一些不同，它没有必须写在参数表最后的限制，甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename R &#x3D; int, typename U&gt;</span><br><span class="line">R func(U val)</span><br><span class="line">&#123;</span><br><span class="line">	return val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	func(97);			&#x2F;&#x2F;R&#x3D;int, U&#x3D;int</span><br><span class="line">	func&lt;char&gt;(97);   	&#x2F;&#x2F;R&#x3D;char , U&#x3D;char</span><br><span class="line">	func&lt;double, int&gt;;	&#x2F;&#x2F;R&#x3D;double, U&#x3D;int</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="C-11列表初始化（统一了初始化方式）"><a href="#C-11列表初始化（统一了初始化方式）" class="headerlink" title="C++11列表初始化（统一了初始化方式）"></a>C++11列表初始化（统一了初始化方式）</h1><ul>
<li><p>C++98/03中的对象初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化列表</span><br><span class="line">int i_arr[3] &#x3D; &#123;1,2,3&#125;;  &#x2F;&#x2F;普通数组</span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">	int x;</span><br><span class="line">	struct B</span><br><span class="line">	&#123;</span><br><span class="line">		int i;</span><br><span class="line">		int j;</span><br><span class="line">	&#125;b;</span><br><span class="line">&#125;a &#x3D; &#123;1, &#123;2,3&#125;&#125;;	&#x2F;&#x2F;POD类型(plain old data)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;拷贝初始化(copy-initialization)</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Foo(int)&#123;&#125;</span><br><span class="line">&#125;foo&#x3D;123;		&#x2F;&#x2F;徐娅萍拷贝构造函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;直接初始化（direct-initialization）</span><br><span class="line">int j(0);</span><br><span class="line">Foo bar(123);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="C-11-lambda匿名函数用法"><a href="#C-11-lambda匿名函数用法" class="headerlink" title="C++11 lambda匿名函数用法"></a>C++11 lambda匿名函数用法</h1><ul>
<li><p>定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[外部变量访问方式说明符](参数)mutable noexcept&#x2F;throw -&gt; 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">	函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>[外部变量访问方式说明符]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[]方括用于向编译器表明当前是一个lambda表达式，其不能被省略。在方括号内部，可以注明当前lambda函数的函数体中可以使用哪些&quot;外部变量&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>(参数)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">和普通函数的定义一样，lambda匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同()小括号一起省略；</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>mutable</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此关键字可以省略，如果使用则之前的()小括号将不能省略(参数个数可以为0)。默认情况下，对于以值传递方式引入的外部变量，不允许在lambda表达式内部修改它们的值(可以理解为这部分变量都是const常量)。而如果想修改它们，就必须使用mutable关键字。</span><br><span class="line">注意：对于以值传递方式引入的外部变量，lambda表达式修改的是拷贝的那一份，并不会修改真正的外部变量；</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>noexcept/throw()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以省略，如果使用，在之前的()小括号将不能省略(参数个数可以为0).默认情况下，lambda函数的函数体中可以抛出任何类型的异常。而标注noexcept关键字，则表示函数体内不会抛出任何异常；使用throw()可以指定lambda函数内部可以抛出的异常类型。</span><br><span class="line"></span><br><span class="line">如果lambda函数标有noexcept而函数体内抛出了异常，又或者使用throw()限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用try-catch捕获，会导致程序执行失败。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>-&gt; 返回值类型</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指明lambda匿名函数的返回值类型。值得一提的是，如果lambda函数体内只有一个return语句，或者该函数返回void，则编辑器可以自行推断出返回类型，此情况可以直接忽略 &#39;-&gt;返回值类型&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>函数体</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">和普通函数一样，lambda匿名函数包含的内部代码都放置在函数体中，该函数体除了可以使用指定传递进来的参数之外，还以可以使用指定的外部变量义级全局范围内的所有全局变量。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>lambda匿名函数中的[外部变量]</code></p>
<table>
<thead>
<tr>
<th>外部变量格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>空方括号白哦是当前lambda匿名函数中不导入任何外部变量</td>
</tr>
<tr>
<td>[=]</td>
<td>只有一个 <code>=</code> 等号，表示以值传递的方式导入所有外部变量</td>
</tr>
<tr>
<td>[val1, val2,…]</td>
<td>表示以值传递的方式导入val1，val2等指定的外部变量，同时多个变量之间没有先后次序</td>
</tr>
<tr>
<td>[&amp;val1, &amp;val2,…]</td>
<td>表示以引用传递的方式导入val1，val2等指定的外部变量，多个变量之间没有先后次序</td>
</tr>
<tr>
<td>[val,&amp;val2,…]</td>
<td>以上两种方式还可以混合使用，变量之间内有前后次序</td>
</tr>
<tr>
<td>[=,&amp;val1,…]</td>
<td>表示除val1以引用传递的方式导入外，其他外部变量都以值传递的方式导入。</td>
</tr>
<tr>
<td>this</td>
<td>表示以值传递的方式导入当前的this指针</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="C-11非受限联合体-union"><a href="#C-11非受限联合体-union" class="headerlink" title="C++11非受限联合体(union)"></a>C++11非受限联合体(union)</h1><ul>
<li>POD(Plain Old Data)的特征<ol>
<li>没有用户自定义的构造函数，析构函数，拷贝构造函数和移动构造函数。</li>
<li>不能包含虚函数和虚基类。</li>
<li>不能包含虚函数和虚基类。</li>
<li>非静态成员必须声明为public。</li>
<li>类中的第一个非静态成员的类型与其基类不同</li>
<li>在类或者结构体继承时，满足一下两种情况之一：<ul>
<li>派生类中有非静态成员，且只有一个仅包含静态成员的基类；</li>
<li>基类有非静态成员，而派生类没有非静态成员。</li>
</ul>
</li>
<li>此外，所有兼容C语言的数据类型都是POD类型（struct， union等不能违背上述规则）</li>
</ol>
</li>
<li>C++11允许联合体有静态成员</li>
</ul>
<h2 id="非受限联合体的复制注意事项"><a href="#非受限联合体的复制注意事项" class="headerlink" title="非受限联合体的复制注意事项"></a>非受限联合体的复制注意事项</h2><p>C++11规定，如果非首先联合体内有一个非POD的成员，而该成员拥有自定义的析构函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数，拷贝赋值操作符义级析构函数等，也将被删除。</p>
<ul>
<li><p>这条规则可能导致对象构造失败，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">union U&#123;</span><br><span class="line">	string s;</span><br><span class="line">	int n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	U u; 	&#x2F;&#x2F;构造失败，因为U的构造函数被删除</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在上面的例子中，因为string类拥有自定义的构造函数，所以U的构造函数被删除；定义U的类型变量u需要调用默认构造函数，所以u也就无法定义成功。</p>
<p>解决上面问题的一般需要用到 placement new，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">union U&#123;</span><br><span class="line">	string s;</span><br><span class="line">	int n;</span><br><span class="line">public:</span><br><span class="line">	U() &#123;new(&amp;s) string;&#125;</span><br><span class="line">	~U() &#123;s.~string();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	U u; 	&#x2F;&#x2F;构造失败，因为U的构造函数被删除</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">placement new 是new关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆(heap)上生成对象。相应地，将常见的new的用法称为operator new，它只能在heap上生成对象。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>placement new的语法格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new(address) ClassConstruct(...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>address表示已有内存的地址，该内存可以在栈上，也可以在堆上；ClassConstruct(…)表示调用类的构造函数，如果构造哈数没有参数，也可以省略括号。</p>
</li>
<li><p>placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在address指定的内存中。</p>
</li>
</ul>
<h2 id="非受限联合体的匿名声明和“枚举式类”"><a href="#非受限联合体的匿名声明和“枚举式类”" class="headerlink" title="非受限联合体的匿名声明和“枚举式类”"></a>非受限联合体的匿名声明和“枚举式类”</h2><p>匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">union U&#123;</span><br><span class="line">	union&#123;int x;&#125;;   &#x2F;&#x2F;此联合体为匿名联合体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为“枚举式类”，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">public:</span><br><span class="line">    Student(bool g, int a): gender(g), age(a)&#123;&#125;</span><br><span class="line">    bool gender;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Singler&#123;</span><br><span class="line">public:</span><br><span class="line">	enum Type &#123;STUDENT, NATIVE, FOREIGER&#125;;</span><br><span class="line">	Singer(bool g, int a) : s(g,a)&#123;t &#x3D; STUDENT;&#125;</span><br><span class="line">	Singer(int i): id(i)&#123;t &#x3D; NATIVE;&#125;</span><br><span class="line">	Singer(const char *n, int s)</span><br><span class="line">	&#123;</span><br><span class="line">		int size &#x3D; (s &gt; 9) ? 0 :s;</span><br><span class="line">		memcpy(name,n,size);</span><br><span class="line">		name[s] &#x3D; &#39;\0&#39;;</span><br><span class="line">		t &#x3D; FOREIGER;</span><br><span class="line">	&#125;</span><br><span class="line">	~Singer()&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">	Type t;</span><br><span class="line">	union &#123;</span><br><span class="line">		Student s;</span><br><span class="line">		int id;</span><br><span class="line">		char name[10];</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Singer(true, 13);</span><br><span class="line">    Singer(310217);</span><br><span class="line">    Singer(&quot;J Michael&quot;, 9);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中使用了一个匿名非受限联合体，它作为类Singer的“变长成员”来使用，这样的变长成员给类的编写带来了更大的灵活性。</p>
<h1 id="C-11-for循环-基于范围的循环-详解"><a href="#C-11-for循环-基于范围的循环-详解" class="headerlink" title="C++11 for循环(基于范围的循环)详解"></a>C++11 for循环(基于范围的循环)详解</h1><p>for循环的格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(表达式 1; 表达式 2; 表达式 3)&#123;</span><br><span class="line">    &#x2F;&#x2F;循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++11中，新增了如下格式的循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (declaration : expression)&#123;</span><br><span class="line">    &#x2F;&#x2F;循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>declaration : 表示此处要定义一个变量，该变量的类型为要变量序列中存储元素的类型。在C++11标准中，declaration参数处定义的变量类型可以用auto关键字表示，该关键字可以使编译器自行推导出该变量的数据类型。</p>
</li>
<li><p>expression：表示要遍历的序列，常见的可以为事先定义好的普通数组或者容器，还可以是用 {} 大括号初始化的序列。</p>
</li>
<li><p>在使用新语法格式的for循环遍历某个序列时，如果需要遍历的同时修改序列中元素的值，实现方案是在declaration参数处定义引用形式的变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    char arc[] &#x3D; &quot;abcde&quot;;</span><br><span class="line">    vector&lt;char&gt;myvector(arc, arc + 5);</span><br><span class="line">    &#x2F;&#x2F;for循环遍历并修改容器中各个字符的值</span><br><span class="line">    for (auto &amp;ch : myvector) &#123;</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;for循环遍历输出容器中各个字符</span><br><span class="line">    for (auto ch : myvector) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="C-11-constexpr：验证是否为常量表达式"><a href="#C-11-constexpr：验证是否为常量表达式" class="headerlink" title="C++11 constexpr：验证是否为常量表达式"></a>C++11 constexpr：验证是否为常量表达式</h1><h1 id="C-11-右值引用"><a href="#C-11-右值引用" class="headerlink" title="C++11 右值引用"></a>C++11 右值引用</h1><table>
<thead>
<tr>
<th>引用类型</th>
<th>非常量左值</th>
<th>常量左值</th>
<th>非常量右值</th>
<th>常量右值</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>非常量左值引用</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>无</td>
</tr>
<tr>
<td>常量左值引用</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>常用于类中构建拷贝构造函数</td>
</tr>
<tr>
<td>非常量左值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>移动语义，完美转发</td>
</tr>
<tr>
<td>常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>无实际用途</td>
</tr>
</tbody></table>
<h1 id="C-11-移动构造函数"><a href="#C-11-移动构造函数" class="headerlink" title="C++11 移动构造函数"></a>C++11 移动构造函数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">移动语义，指的是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的是将其他对象（通常是临时对象）拥有的内存资源“移为己用”。</span><br></pre></td></tr></table></figure>

<p>demo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class demo</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	&#x2F;* data *&#x2F;</span><br><span class="line">	int *num;</span><br><span class="line">public:</span><br><span class="line">	demo(&#x2F;* args *&#x2F;) : num(new int(0))&#123;</span><br><span class="line">		cout &lt;&lt;&quot;construct!&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	demo(const demo &amp;d):num(new int(*d.num))</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;copy construct! &quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	demo(demo &amp;&amp;d):num(d.num)</span><br><span class="line">	&#123;</span><br><span class="line">		d.num &#x3D; NULL;</span><br><span class="line">		cout &lt;&lt; &quot;move construct!&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	~demo()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;class destruc!&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">demo get_demo()</span><br><span class="line">&#123;</span><br><span class="line">	return demo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	demo a &#x3D; get_demo();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-11-move-函数：将左值强制转换为右值"><a href="#C-11-move-函数：将左值强制转换为右值" class="headerlink" title="C++11 move()函数：将左值强制转换为右值"></a>C++11 move()函数：将左值强制转换为右值</h1><ul>
<li><p>移动构造函数的调用时机是：用同类的右值对象初始化新对象。</p>
</li>
<li><p>move() 函数的语法格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">move(arg)</span><br></pre></td></tr></table></figure>

<ul>
<li>arg表示指定的左值对象。该函数会返回arg对象的右值形式。</li>
</ul>
</li>
</ul>
<h1 id="C-11-完美转发及实现方法"><a href="#C-11-完美转发及实现方法" class="headerlink" title="C++11 完美转发及实现方法"></a>C++11 完美转发及实现方法</h1><ul>
<li><p>完美转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">完美转发指的是函数模板可以将自己的参数“完美”地转发给内部调用的其他函数。所谓完美，及不仅能准确地转发参数的值，还能保证被转发参数的左右值属性不变。</span><br></pre></td></tr></table></figure>
</li>
<li><p>nullptr 是nullptr_t 类型的右值常量，专用于初始化空类型指针。</p>
</li>
</ul>
<h1 id="C-11-shared-ptr智能指针"><a href="#C-11-shared-ptr智能指针" class="headerlink" title="C++11 shared_ptr智能指针"></a>C++11 shared_ptr智能指针</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所谓智能指针，可以从字面上理解为“智能”的指针。具体来讲，智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存。</span><br><span class="line">也就是说，使用智能指针可以很好的避免“忘记释放内存而导致内存泄漏”问题文献。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>shared_ptr 智能指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">智能指针都是以类模板的方式实现，shared_ptr&lt;T&gt; (T表示指针指向的具体数据类型) 使用需要包含如下两行代码</span><br><span class="line"></span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>shared_ptr智能指针的创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p1 ;  &#x2F;&#x2F;不传入任何实参</span><br><span class="line">std::shared_ptr&lt;int&gt; p2(nullptr);	&#x2F;&#x2F;传入空指针nullptr</span><br><span class="line">std::shared_ptr&lt;int&gt; p3(new int(10));  &#x2F;&#x2F;</span><br><span class="line">std::shared_ptr&lt;int&gt; p4 &#x3D; std::make_shared&lt;int&gt;(10);</span><br></pre></td></tr></table></figure>
</li>
<li><p>shared_ptr<T> 提供又相应的拷贝构造函数和移动构造函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;调用拷贝构造函数</span><br><span class="line">std::shared_ptr&lt;int&gt; p4(p3);</span><br><span class="line">&#x2F;&#x2F;或者 std::shared_ptr&lt;int&gt; p4 &#x3D; p3;</span><br><span class="line">&#x2F;&#x2F;调用移动构造函数</span><br><span class="line">std::shared_ptr&lt;int&gt; p5(std::move(p4)); </span><br><span class="line">&#x2F;&#x2F;或者 std::shared_ptr&lt;int&gt; p5 &#x3D; std::move(p4);</span><br><span class="line"></span><br><span class="line">p3 和 p4 都是 shared_ptr 类型的智能指针，因此可以用 p3 来初始化 p4，由于 p3 是左值，因此会调用拷贝构造函数。需要注意的是，如果 p3 为空智能指针，则 p4 也为空智能指针，其引用计数初始值为 0；反之，则表明 p4 和 p3 指向同一块堆内存，同时该堆空间的引用计数会加 1.</span><br><span class="line"></span><br><span class="line">而对于 std::move(p4) 来说，该函数会强制将 p4 转换成对应的右值，因此初始化 p5 调用的是移动构造函数。另外和调用拷贝构造函数不同，用 std::move(p4) 初始化 p5，会使得 p5 拥有了 p4 的堆内存，而 p4 则变成了空智能指针。</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义shared_ptr智能指针的释放规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;指定 default_delete 作为释放规则</span><br><span class="line">std::shared_ptr&lt;int&gt; p6(new int[10], std::default_delete&lt;int[]&gt;());</span><br><span class="line">&#x2F;&#x2F;自定义释放规则</span><br><span class="line">void deleteInt(int*p) &#123;</span><br><span class="line">    delete []p;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;初始化智能指针，并自定义释放规则</span><br><span class="line">std::shared_ptr&lt;int&gt; p7(new int[10], deleteInt);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>shared_ptr&lt;T&gt;模板提供的成员方法</p>
<table>
<thead>
<tr>
<th>成员方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>operator=()</td>
<td>重载赋值号，使得同一类型的 shared_ptr 智能指针可以相互赋值。</td>
</tr>
<tr>
<td>operator*()</td>
<td>重载*号，夺取当前shared_ptr智能指针对象指向的数据</td>
</tr>
<tr>
<td>operator-&gt;()</td>
<td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个相同类型 shared_ptr 智能指针的内容。</td>
</tr>
<tr>
<td>reset()</td>
<td>当函数没有实参时，该函数会使当前 shared_ptr 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的 shared_ptr 对象会获得该存储空间的所有权，并且引用计数的初始值为 1。</td>
</tr>
<tr>
<td>get()</td>
<td>获得 shared_ptr 对象内部包含的普通指针。</td>
</tr>
<tr>
<td>use_count()</td>
<td>返回同当前 shared_ptr 对象（包括它）指向相同的所有 shared_ptr 对象的数量。</td>
</tr>
<tr>
<td>unique()</td>
<td>判断当前 shared_ptr 对象指向的堆内存，是否不再有其它 shared_ptr 对象再指向它。</td>
</tr>
<tr>
<td>operator bool()</td>
<td>判断当前 shared_ptr 对象是否为空智能指针，如果是空指针，返回 false；反之，返回 true。</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;构建 2 个智能指针</span><br><span class="line">    std::shared_ptr&lt;int&gt; p1(new int(10));</span><br><span class="line">    std::shared_ptr&lt;int&gt; p2(p1);</span><br><span class="line">    &#x2F;&#x2F;输出 p2 指向的数据</span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    p1.reset();&#x2F;&#x2F;引用计数减 1,p1为空指针</span><br><span class="line">    if (p1) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;p1 不为空&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;p1 为空&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;以上操作，并不会影响 p2</span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F;判断当前和 p2 同指向的智能指针有多少个</span><br><span class="line">    cout &lt;&lt; p2.use_count() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="C-11-unique-ptr智能指针"><a href="#C-11-unique-ptr智能指针" class="headerlink" title="C++11 unique_ptr智能指针"></a>C++11 unique_ptr智能指针</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">作为智能指针的一种，unique_ptr 指针自然也具备“在适当时机自动释放堆内存空间”的能力。和 shared_ptr 指针最大的不同之处在于，unique_ptr 指针指向的堆内存无法同其它 unique_ptr 共享，也就是说，每个 unique_ptr 指针都独自拥有对其所指堆内存空间的所有权。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>unique_ptr智能指针的创建</p>
<ol>
<li><p>创建空的unique_ptr指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; p1();</span><br><span class="line">std::unique_ptr&lt;int&gt; p2(nullptr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 unique_ptr 指针的同时，也可以明确其指向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; p3(new int);</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于 unique_ptr 类型指针不共享各自拥有的堆内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; p4(new int);</span><br><span class="line">std::unique_ptr&lt;int&gt; p5(p4);&#x2F;&#x2F;错误，堆内存不共享</span><br><span class="line">std::unique_ptr&lt;int&gt; p5(std::move(p4));&#x2F;&#x2F;正确，调用移动构造函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认情况下，unique_ptr 指针采用 std::default_delete<T> 方法释放堆内存。当然，我们也可以自定义符合实际场景的释放规则。值得一提的是，和 shared_ptr 指针不同，为 unique_ptr 自定义释放规则，只能采用函数对象的方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;自定义的释放规则</span><br><span class="line">struct myDel</span><br><span class="line">&#123;</span><br><span class="line">    void operator()(int *p) &#123;</span><br><span class="line">        delete p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::unique_ptr&lt;int, myDel&gt; p6(new int);</span><br><span class="line">&#x2F;&#x2F;std::unique_ptr&lt;int, myDel&gt; p6(new int, myDel());</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>unique_ptr&lt;T&gt;模板类提供的成员方法</p>
<table>
<thead>
<tr>
<th>成员函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>operator*()</td>
<td>获取当前 unique_ptr 指针指向的数据。</td>
</tr>
<tr>
<td>operator-&gt;()</td>
<td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td>
</tr>
<tr>
<td>operator =()</td>
<td>重载了 = 赋值号，从而可以将 nullptr 或者一个右值 unique_ptr 指针直接赋值给当前同类型的 unique_ptr 指针。</td>
</tr>
<tr>
<td>operator <a href=""></a></td>
<td>重载了 [] 运算符，当 unique_ptr 指针指向一个数组时，可以直接通过 [] 获取指定下标位置处的数据。</td>
</tr>
<tr>
<td>get()</td>
<td>获取当前 unique_ptr 指针内部包含的普通指针。</td>
</tr>
<tr>
<td>get_deleter()</td>
<td>获取当前 unique_ptr 指针释放堆内存空间所用的规则。</td>
</tr>
<tr>
<td>operator bool()</td>
<td>unique_ptr 指针可直接作为 if 语句的判断条件，以判断该指针是否为空，如果为空，则为 false；反之为 true。</td>
</tr>
<tr>
<td>release()</td>
<td>释放当前 unique_ptr 指针对所指堆内存的所有权，但该存储空间并不会被销毁。</td>
</tr>
<tr>
<td>reset(p)</td>
<td>其中 p 表示一个普通指针，如果 p 为 nullptr，则当前 unique_ptr 也变成空指针；反之，则该函数会释放当前 unique_ptr 指针指向的堆内存（如果有），然后获取 p 所指堆内存的所有权（p 为 nullptr）。</td>
</tr>
<tr>
<td>swap(x)</td>
<td>交换当前 unique_ptr 指针和同类型的 x 指针。</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;int&gt; p5(new int);</span><br><span class="line">    *p5 &#x3D; 10;</span><br><span class="line">    &#x2F;&#x2F; p 接收 p5 释放的堆内存</span><br><span class="line">    int * p &#x3D; p5.release();</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F;判断 p5 是否为空指针</span><br><span class="line">    if (p5) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;p5 is not nullptr&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;p5 is nullptr&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::unique_ptr&lt;int&gt; p6;</span><br><span class="line">    &#x2F;&#x2F;p6 获取 p 的所有权</span><br><span class="line">    p6.reset(p);</span><br><span class="line">    cout &lt;&lt; *p6 &lt;&lt; endl;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="C-11-weak-ptr智能指针"><a href="#C-11-weak-ptr智能指针" class="headerlink" title="C++11 weak_ptr智能指针"></a>C++11 weak_ptr智能指针</h1><ul>
<li><p>weak_ptr指针的创建</p>
<ol>
<li><p>创建一个空weak_ptr指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::weak_ptr&lt;int&gt; wp1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>凭借已有的 weak_ptr 指针，可以创建一个新的 weak_ptr 指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::weak_ptr&lt;int&gt; wp2 (wp1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>weak_ptr 指针更常用于指向某一 shared_ptr 指针拥有的堆内存，因为在构建 weak_ptr 指针对象时，可以利用已有的 shared_ptr 指针为其初始化.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; sp (new int);</span><br><span class="line">std::weak_ptr&lt;int&gt; wp3 (sp);</span><br></pre></td></tr></table></figure>

<p>wp3 指针和 sp 指针有相同的指针。再次强调，weak_ptr 类型指针不会导致堆内存空间的引用计数增加或减少。</p>
</li>
</ol>
</li>
<li><p>weak_ptr模板类提供的成员方法</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>operator=()</td>
<td>重载 = 赋值运算符，是的 weak_ptr 指针可以直接被 weak_ptr 或者 shared_ptr 类型指针赋值。</td>
</tr>
<tr>
<td>swap(x)</td>
<td>其中 x 表示一个同类型的 weak_ptr 类型指针，该函数可以互换 2 个同类型 weak_ptr 指针的内容。</td>
</tr>
<tr>
<td>reset()</td>
<td>将当前 weak_ptr 指针置为空指针。</td>
</tr>
<tr>
<td>use_count()</td>
<td>查看指向和当前 weak_ptr 指针相同的 shared_ptr 指针的数量。</td>
</tr>
<tr>
<td>expired()</td>
<td>判断当前 weak_ptr 指针为否过期（指针为空，或者指向的堆内存已经被释放）。</td>
</tr>
<tr>
<td>lock()</td>
<td>如果当前 weak_ptr 已经过期，则该函数会返回一个空的 shared_ptr 指针；反之，该函数返回一个和当前 weak_ptr 指向相同的 shared_ptr 指针。</td>
</tr>
</tbody></table>
</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>基础篇、到底应该怎么理解&quot;平均负载&quot;</title>
    <url>/dc0156fc.html</url>
    <content><![CDATA[<h1 id="什么是平均负载？"><a href="#什么是平均负载？" class="headerlink" title="什么是平均负载？"></a>什么是平均负载？</h1><p>正确定义：<br><code>平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和CPU使用率并没有直接关系。</code></p>
<p>错误定义：<br><code>单位时间内的CPU使用率</code><br>下面先介绍一下可运行状态进程和不可中断状态进程：<br>1. 可运行状态进程</p>
<p><code>可运行状态状态的进程，是指正在使用CPU或者正在等待CPU的进程。</code></p>
<p>比如使用ps命令看到的，处于R状态（Running 或 Runnable）的进程。</p>
<p>2. 不可中断状态进程</p>
<p><code>不可中断状态的进程是正处于内核态关键流程中的进程，并且这些流程是不可打断的。不可中断状态实际上是系统对进程和硬件设备的一种保护机制。</code></p>
<p>比如最常见的是等待硬件设备的I/O响应，也就是我们在ps命令中看到的D状态（Uninterruptible Sleep，也称为Disk Sleep）的进程。</p>
<p>3.过载经验值</p>
<p><code>平均负载高于CPU核数70%的时候</code></p>
<h1 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h1><h2 id="CPU核数"><a href="#CPU核数" class="headerlink" title="CPU核数"></a>CPU核数</h2><p>1.  <strong>lscpu</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lscpu</span><br><span class="line">Architecture:        x86_64</span><br><span class="line">CPU op-mode(s):      32-bit, 64-bit</span><br><span class="line">Byte Order:          Little Endian</span><br><span class="line">CPU(s):              8</span><br><span class="line">On-line CPU(s) list: 0-7</span><br><span class="line">Thread(s) per core:  1</span><br><span class="line">Core(s) per socket:  8</span><br><span class="line">Socket(s):           1</span><br><span class="line">NUMA node(s):        1</span><br><span class="line">Vendor ID:           GenuineIntel</span><br><span class="line">CPU family:          6</span><br><span class="line">Model:               142</span><br><span class="line">Model name:          Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz</span><br><span class="line">Stepping:            12</span><br><span class="line">CPU MHz:             1991.999</span><br><span class="line">BogoMIPS:            3983.99</span><br><span class="line">Virtualization:      VT-x</span><br><span class="line">Hypervisor vendor:   VMware</span><br><span class="line">Virtualization type: full</span><br><span class="line">L1d cache:           32K</span><br><span class="line">L1i cache:           32K</span><br><span class="line">L2 cache:            256K</span><br><span class="line">L3 cache:            8192K</span><br><span class="line">NUMA node0 CPU(s):   0-7</span><br></pre></td></tr></table></figure>
<p>2. <strong>grep ‘model name’ /proc/cpuinfo | wc -l</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep &#39;model name&#39; &#x2F;proc&#x2F;cpuinfo | wc -l</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h2 id="显示负载"><a href="#显示负载" class="headerlink" title="显示负载"></a>显示负载</h2><p>1.  <strong>uptime</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 08:45:52 up 1 day, 10:29,  2 users,  load average: 0.44, 0.10, 0.03</span><br></pre></td></tr></table></figure>
<p><code>load average：显示的顺序是最近1分钟，5分钟，15分钟的平均负载情况。通过观察趋势，判定平均负载是否异常。</code></p>
<p>1.  <strong>top</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ top</span><br><span class="line">top - 08:46:50 up 1 day, 10:30,  2 users,  load average: 0.21, 0.09, 0.03</span><br><span class="line">Tasks: 396 total,   2 running, 298 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.9 us,  0.4 sy,  0.0 ni, 98.6 id,  0.0 wa,  0.0 hi,  0.1 si,  0.0 st</span><br><span class="line">KiB Mem :  2006004 total,   149252 free,  1172820 used,   683932 buff&#x2F;cache</span><br><span class="line">KiB Swap:  1942896 total,  1430896 free,   512000 used.   637672 avail Mem</span><br></pre></td></tr></table></figure>
<p>3. <strong>watch -d uptime</strong><br><code>-d 会高亮显示变化的区域</code></p>
<p>4. <strong>stress 压测命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--cpu n  cpu压测选项</span><br><span class="line">--i  n     io压力测试选项， </span><br><span class="line">-c  n  进程数压测选项</span><br><span class="line">-timeout  执行时间</span><br></pre></td></tr></table></figure>

<p>5. <strong>mpstat</strong><br><code>多核CPU 性能分析工具 ，mpstat  -P ALL :监视所有CPU</code></p>
<p>6. <strong>pidstat</strong><br><code>进程性能分析工具， -u 显示cpu利用率</code></p>
<h1 id="平均负载和cpu使用的区别"><a href="#平均负载和cpu使用的区别" class="headerlink" title="平均负载和cpu使用的区别"></a>平均负载和cpu使用的区别</h1><p><strong>CPU使用率</strong><br><code>CPU使用率是指cpu繁忙情况的统计</code></p>
<p>情况1：<br><code>CPU密集型进程， CPU使用率和平均负载基本一致</code></p>
<p>情况2：<br><code>IO密集型进程， 平均负载升高，CPU使用率不一定升高</code></p>
<p>情况3：<br><code>大量等待CPU的进程调度，平均负载升高，CPU使用率也升高</code></p>
<h1 id="平均负载升高时，如何调优"><a href="#平均负载升高时，如何调优" class="headerlink" title="平均负载升高时，如何调优"></a>平均负载升高时，如何调优</h1><h2 id="CPU密集型进程case"><a href="#CPU密集型进程case" class="headerlink" title="CPU密集型进程case"></a>CPU密集型进程case</h2><ul>
<li>mpstat -p ALL 5: -P ALL 表示监控所有CPU， 5表示每5秒刷新一次数据，观察是否有某个CPU很高， 但iowait很低。</li>
<li>pidstat -u 5 1: 每5秒输出一组数据，观察哪个进程%cpu很高，但是%wait很低， 极有可能就是这个进程导致cpu飙升。<h2 id="IO密集型进程case"><a href="#IO密集型进程case" class="headerlink" title="IO密集型进程case"></a>IO密集型进程case</h2></li>
<li>mpstat -P ALL 5 : 观察是否某个cpu的%iowait很高，同时%usr也较高</li>
<li>pidstat -u 5 1  : 观察哪个进程%wait较高，同时%cpu也较高<h2 id="大量进程case"><a href="#大量进程case" class="headerlink" title="大量进程case"></a>大量进程case</h2></li>
<li>pidstat -u 5 1  : 观察那些%wait 较高的进程是否有很多。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
